
<div align="center">

![](https://github.com/small-rose/small-o2o-compare/blob/main/o2o-logo.png)

[![](https://img.shields.io/badge/blog-@small.rose-ff69b4.svg)](https://zhangxiaocai.cn)
![](https://img.shields.io/badge/java-@>=1.8-blueviolet.svg)
![](https://img.shields.io/badge/maven-@3.6.3-yellow.svg)
![](https://img.shields.io/badge/springboot-@2.5.14-green.svg)
![](https://img.shields.io/badge/druid-@1.2.6-critical.svg)
![](https://img.shields.io/badge/lombok-@1.18.24-blue.svg)
![](https://img.shields.io/badge/easyexcel-@2.2.8-skyblue.svg)
![](https://img.shields.io/badge/oracle-@11gR2-blueviolet.svg)
![](https://img.shields.io/badge/oceanbase-@3.2.3.3-yellow.svg)

</div>

--------------------

# small-o2o-compare

## 诞生背景

> 去O的过程中会经常需要进行数据库对象对比，其实只要有SQL，使用compare和Excel也可以轻松实现对比。但是考虑对比的横向对齐度和后续生成修复语句，程序实现更方便，因此有了这个小工具。

1、进行数据库差异对比

2、快速筛选差异

3、生成索引或列的修复语句


## 元数据对比


目前支持的对比：

- [x] OB-ORACLE 和 ORALCE
- [x] ORACLE 和 ORALCE
- [x] OB-ORACLE 和 OB-ORALCE

后续计划支持

- [ ] OB-MYSQL 和 MYSQL
- [ ] MYSQL 和 MYSQL
- [ ] OB-MYSQL 和 OB-MYSQL

### Reference Documentation

#### 1、对比基础的元数据信息

可以查视图: USER_OBJECTS、DBA_OBJECTS、ALL_OBJECTS 

```sql
SELECT OBJECT_TYPE, COUNT FROM (SELECT 0BJECT_TYPE, COUNT(1) COUNT FROM USER_OBJECTS SGROUP BY OBJECT_TYPE --ORDER BY OBJECT_TYPE
UNION ALL
SELECT 'INDEX-' II UNIQUENESSSOBJECT_TYPE ，COUNT(1) COUNT FROM USER_INDEXES GROUP BY UNIQUENESS)ORDER BY OBJECT_TYPE
```

2、对比表清单

(1) 全部表清单

```sql
SELECT T.TABLE NAME,T.STATUS FROM USER TABLES T ORDER BY T.TABLE NAME ;
```

(2) 分区表

```sql
--分区表信息
SELECT P.TABLE_NAME, P.PARTITIONING_TYPE, P.SUBPARTITIONING_TYPE, P.PARTITION_COUNT FROM user_PART_TABLES p where p.PARTITIONING_TYPE='LIST' ORDER BY  P.TABLE_NAME

-- 查分区键
SELECT * FROM USER_PART_KEY_COLUMNS  ;
```

(2) 临时表

```sql
SELECT T.TABLE_NAME, T.TEMPORARY, T.STATUS FROM USER_TABLES T WHERE T.TEMPORARY ='Y' ;
```

3、对比表对应的列

- 对比列可包含名称、类型、长度、非空、默认值。可根据需要调整SQL。

```sql
SELECT TC.TABLE_NAME,
       TC.COLUMN_NAME,
       CASE
           WHEN TC.DATA_TYPE = 'DATE' THEN TC.DATA_TYPE
           WHEN TC.DATA_TYPE = 'NUMBER' THEN (CASE WHEN TC.DATA_PRECISION IS NOT NULL THEN
                                                      TC.DATA_TYPE || '(' || TC.DATA_PRECISION || ',' || TC.DATA_SCALE || ')'
                                                  ELSE TC.DATA_TYPE END)
           WHEN TC.CHARACTER_SET_NAME IS NOT NULL
               THEN TC.DATA_TYPE || '(' || TC.CHAR_LENGTH || ')'
           ELSE
               TC.DATA_TYPE || '(' || TC.DATA_LENGTH || ')' END  DATA_TYPE,
       CASE TC.NULLABLE
           WHEN 'N'
               THEN (CASE WHEN TC.DATA_DEFAULT IS NULL THEN 'NOT NULL'
                         ELSE ('DEFAULT ' || TC.DATA_DEFAULT  || ' NOT NULL') END)
           ELSE (CASE WHEN TC.DATA_DEFAULT IS NULL THEN ''
                     ELSE ('DEFAULT ' || TC.DATA_DEFAULT || '') END) END EXTEND,
       TC.NULLABLE,
       TC.DATA_DEFAULT,
       TC.COLUMN_ID
FROM USER_TAB_COLUMNS TC
ORDER BY TC.TABLE_NAME, TC.COLUMN_ID ;
```

> 注意在oracle中 DATA_DEFAULT 不能直接转字符串。需要使用自研函数LONG_TO_CHAR



5、对比表索引

含唯一索引和普通索引、函数索引

处理索引，先删后建

主键索引

```sql
SELECT CC.TABLE_NAME, CC.CONSTRAINT_NAME,
        LISTAGG(CC.COLUMN_NAME, ',')WITHIN GROUP ( ORDER BY CC.TABLE_NAME, CC.COLUMN_NAME) AS COLUMN_NAME
FROM USER_CONS_COLUMNS CC INNER JOIN USER_CONSTRAINTS C ON  CC.CONSTRAINT_NAME= C.CONSTRAINT_NAME
WHERE CC.TABLE_NAME = C.TABLE_NAME AND C.CONSTRAINT_TYPE ='P' AND CC.TABLE_NAME NOT LIKE 'BIN%'
GROUP BY CC.TABLE_NAME, CC.CONSTRAINT_NAME ORDER BY CC.TABLE_NAME, CC.CONSTRAINT_NAME
```

普通（含函数)索引

```sql
-- 查询表索引-含普通索引、函数索引等
SELECT T.TABLE_NAME, T.INDEX_NAME,
       LISTAGG(CASE
                   WHEN INSTR(I.INDEX_TYPE, 'FUNCTION') > 0 THEN NEWCOLUMN_NAME
                   ELSE T.COLUMN_NAME || ' ' || T.DESCEND END, ',')
               WITHIN GROUP (ORDER BY T.TABLE_NAME,T.INDEX_NAME,T.COLUMN_POSITION) AS COLUMN_NAME,
       I.INDEX_TYPE,
       I.UNIQUENESS
FROM (SELECT N.*,
             (CASE
                  WHEN INSTR(N.COLUMN_NAME, 'SYS_NC') > 0 THEN
                      (SELECT INDEX_COLUMN_EXPRESSION(E.TABLE_NAME, E.INDEX_NAME, E.COLUMN_POSITION)
                       FROM USER_IND_EXPRESSIONS E
                       WHERE E.INDEX_NAME = N.INDEX_NAME AND E.COLUMN_POSITION = N.COLUMN_POSITION)
                  ELSE N.COLUMN_NAME END) AS NEWCOLUMN_NAME
      FROM USER_IND_COLUMNS N
    --WHERE  N.TABLE_NAME = 'ACT_RU_CASE_EXECUTION'
    ) T, USER_INDEXES I
WHERE T.INDEX_NAME = I.INDEX_NAME
  AND T.TABLE_NAME = I.TABLE_NAME
GROUP BY T.TABLE_NAME, T.INDEX_NAME, I.INDEX_TYPE, I.UNIQUENESS
ORDER BY T.TABLE_NAME, T.INDEX_NAME ;
```

6、对比序列

```sql
--名称和数量
SELECT T.SEQUENCE_NAME, T.LAST_NUMBER FROM USER_SEQUENCES T  ORDER BY T.SEQUENCE_NAME ;
--内容对比
SELECT T.SEQUENCE_NAME||','|| T.INCREMENT_BY||','||T.ORDER_FLAG ||','|| T.CYCLE_FLAG||','||T.CACHE_SIZE
FROM USER_SEQUENCES T ORDER BY T.SEQUENCE_NAME;
```

7、对比 TYPE 集合

查声明
```sql
SELECT T.OBJECT_TYPE, T.OBJECT_NAME, T.STATUS FROM USER_OBJECTS T WHERE T.OBJECT_TYPE='TYPE' ORDER BY T.OBJECT_NAME ;
```

查内容
```sql
SELECT * FROM USER_SOURCE T WHERE T.TYPE='TYPE' AND T.NAME = 'TY_TBL_STR_SPLIT' ORDER BY T.NAME, T.LINE ;
```

8、对比表视图声明（可含内容）

查声明
```sql
SELECT T.OBJECT_TYPE, T.OBJECT_NAME, T.STATUS FROM USER_OBJECTS T WHERE T.OBJECT_TYPE='VIEW' ORDER BY T.OBJECT_NAME ;
```

查内容
```sql
SELECT * FROM USER_SOURCE T WHERE T.TYPE='VIEW' AND T.NAME = 'V_TEST' ORDER BY T.NAME, T.LINE ;
```

9、对比函数

查声明
```sql
SELECT T.OBJECT_TYPE, T.OBJECT_NAME, T.STATUS FROM USER_OBJECTS T WHERE T.OBJECT_TYPE='FUNCTION' ORDER BY T.OBJECT_NAME ;
```

查内容
```sql
SELECT * FROM USER_SOURCE T WHERE T.TYPE='FUNCTION' AND T.NAME = 'FN_SPLIT' ORDER BY T.NAME, T.LINE ;
```


10、对比存过声明

查声明
```sql
SELECT T.OBJECT_TYPE, T.OBJECT_NAME, T.STATUS FROM USER_OBJECTS T WHERE T.OBJECT_TYPE='PROCEDURE' ORDER BY T.OBJECT_NAME ;
```

查内容
```sql
SELECT * FROM USER_SOURCE T WHERE T.TYPE='FUNCTION' AND T.NAME = 'PRO_TEST' ORDER BY T.NAME, T.LINE ;
```

11、对比存过包

```sql
SELECT T.OBJECT_TYPE, T.OBJECT_NAME, T.STATUS FROM USER_OBJECTS T 
WHERE T.OBJECT_TYPE IN ('PACKAGE','PACKAGE BODY') ORDER BY T.OBJECT_NAME, T.OBJECT_TYPE ;
```

12、其他

如果有其他需要比较，可以自行扩展。


### 辅助函数

（1）LONG_TO_CHAR
```sql
CREATE OR REPLACE FUNCTION LONG_TO_CHAR(IN_COLUMN VARCHAR2,
                             IN_OWNER VARCHAR,
                             IN_TABLE_NAME VARCHAR,
                             IN_CONDITION VARCHAR2)
    RETURN VARCHAR AS
    TEXT_C1 VARCHAR2(32767);
    SQL_CUR VARCHAR2(2000);
BEGIN
    SQL_CUR := 'SELECT ' || IN_COLUMN || ' FROM ' || IN_OWNER || IN_TABLE_NAME || ' WHERE 1 = 1 ' || IN_CONDITION;
    DBMS_OUTPUT.PUT_LINE(SQL_CUR);
    EXECUTE IMMEDIATE SQL_CUR INTO TEXT_C1;
    TEXT_C1 := SUBSTR(TEXT_C1, 1, 4000); RETURN TEXT_C1;
END
```

（2）INDEX_COLUMN_EXPRESSION

```sql
create FUNCTION  INDEX_COLUMN_EXPRESSION(
    IN_TABLE_NAME VARCHAR2,
    IN_INDEX_NAME VARCHAR2,
    IN_COLUMN_POSITION VARCHAR2
)
RETURN VARCHAR AS
    TEXT_STR VARCHAR2(32767);
    SQL_STR VARCHAR2(2000);
BEGIN
    SQL_STR := 'SELECT COLUMN_EXPRESSION
        FROM USER_IND_EXPRESSIONS T WHERE T.TABLE_NAME ='''|| IN_TABLE_NAME||'''
        AND T.INDEX_NAME = '''|| IN_INDEX_NAME||'''
        AND T.COLUMN_POSITION = '''|| IN_COLUMN_POSITION||''' ';
    EXECUTE IMMEDIATE SQL_STR INTO TEXT_STR;
    TEXT_STR := SUBSTR(TEXT_STR, 1, 4000);
    RETURN TEXT_STR;
END;
/
```
